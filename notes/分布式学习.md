# 分布式理论



## CAP定理

- Consistency	强一致性：多个副本之间保持强一致性
- Available  高可用性：系统提供的服务必须处在可用状态，每次请求都必须返回非错的数据，哪怕不是最新
- Partition Tolerance  分区容错性，如果一个分区挂了，对外还是能够提供满足一致性和可用性的服务

CAP定理：上述三个条件在分布式环境下，最多只能满足两个

## BASE定理

- Basic Available  基本可用：系统出现故障，但依然能够使用，只不过比正常性能有所降低
- Soft State  软状态：允许多个副本之间存在一定的数据延迟，即这段时间内允许可接收的不一致
- Eventually Consistency  最终一致性：软状态时间过后，多个副本的状态是强一致的

这是比较实际的方式。其中的软状态看起来挺吓人，实际上我们可以通过技术手段让用户感知不到软状态的存在，比如

- 因果一致性：节点A和节点B的数据有因果关系，则写入节点A后马上同步到节点B，晚点再同步到无关紧要的节点C。这样用户能够在有限的延迟中在B读A刚写的内容，而AB和C之间的状态也是软状态。
- 会话一致性：将数据的更新框定在一个会话中，对用户来说总能读取最新数据，对系统却可以晚点更新数据库
- 读己之写
- 单调读一致性
- 单调写一致性

总而言之，BASE定理就是一个相对CAP在一定程度上做出妥协，但从用户体验上保证可用。可以说是使用一定的技巧平衡了用户需求和CAP需求

## 2PC协议

即二阶段提交协议，是用于处理分布式事务的一种协议，文字描述大致如下

事务系统中有单点的事务管理器TM和分散在各个节点的资源管理器即数据库RM，客户端与TM交流，再由TM协调各RM进行事务的同步。整个过程分为两个节点

- 阶段一：准备阶段，TM向RM发起事务询问，各RM执行事务，返回执行结果响应。如有失败则中止事务，否则进行下一阶段

  ![image-20200217222049868](https://gdz.oss-cn-shenzhen.aliyuncs.com/notes/image-20200217222049868.png)

- 阶段二：提交阶段，TM想RM发起提交请求，各RM响应提交结果，如所有RM提交成功，则TM再发起正式提交的请求，RM响应ACK；

  ![image-20200217222104104](https://gdz.oss-cn-shenzhen.aliyuncs.com/notes/image-20200217222104104.png)

  如有一个RM提交失败，则TM发起回滚请求，RM响应ACK

  ![image-20200217222114443](https://gdz.oss-cn-shenzhen.aliyuncs.com/notes/image-20200217222114443.png)

这就是二阶段响应，可以看到很多缺点

- 同步阻塞：RM之间要互相等待，效率低
- 单点：只有一个TM，挂了就完了
- 数据不一致：TM向部分RM发起确认提交请求成功，另一部分失败，则会造成数据不一致
- 容错性不好：如果一个RM挂掉，则整个事务都会失败

唯一的优点是简单，实现方便。

[readMore](https://juejin.im/post/5b2664446fb9a00e4a53136e)

## 3PC协议

是对两阶段提交的改进版，主要解决前者的单点问题

- 阶段一：CanCommit。TM询问各RM是否可以开始事务操作，RM回复OK
- 阶段二：PreCommit。TM发出准备提交请求，RM执行事务操作，并准备好，响应OK
- 阶段三：DoCommit。TM发出正式提交请求，RM提交事务，响应ACK，完成事务

还有一个重要的内容TM和RM都有超时响应机制。这样就不会造成RM过久的阻塞，因为超时时RM默认commit。这同时解决了单点故障问题

但他还是存在RM间数据不一致的问题。

## 一致性算法 Paxos



## 一致性算法 Raft



## 分布式系统的时间问题

引入逻辑时钟，即按照事件的因果关系对事件进行先后标记，这个标记称为逻辑时钟，这样可以保证有因果关系的事件按照正确的顺序执行。没有因果关系的事件先处理还是后处理也没什么影响。

