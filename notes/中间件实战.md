# 中间件实战

## 明确学习目标

学习本书的目的并非实战，而是看看在实际操作中这些中间件如何使用。不建议按照书上去做。原因由如下几点。

- 书中涉及到大量工具和框架的配置，而这些自己平时又很少用到，配置起来会浪费大量时间。甚至心态炸裂。
- 自己看这本书的目的，仅仅是想要了解各种中间件在实际使用中是如何操作的。练习不练习，目前并不重要。
- 书中使用了MyBatis，配置起来相当恶心，抛弃，绝对抛弃。
- 仔细看其中的实战代码，多数是Spring Boot对中间件封装后API的使用，并不具有参考价值。

## 缓存中间件 - Redis

### 缓存穿透

查询本就不存在的key，使得每次访问流量打到数据库；解决方案：不存在的key查询结果为null也缓存一小段时间。

### 缓存雪崩

某个时间点，缓存的key集体过期，导致请求全部压到数据库。解决方案：错开过期时间。

### 缓存击穿

与缓存雪崩的区别是，大量请求落到热点key，该热点key失效时这些请求全部压到数据库。解决方案：不让他过期，手动预加载等。

### 使用Redis抢红包

**需求**

- 一个用户发红包，金额为M，指定个数为N
- 多个用户抢红包，要求能够抢到红包的用户最低又0.01元，机会上要公平
- 一个用户仅能抢到一次红包

**方案设计**

分为发红包和抢红包两个子流程。发红包时生成唯一的红包ID，并生成N个随机的红包。

抢红包时从事先生成好的红包中获取，能获取到时表示抢到；不能获取到时表示没有抢到。

![image-20200725124139994](D:\WorkSpace\notes-gd\notes\中间件实战.assets\image-20200725124139994.png)

![image-20200725124203774](D:\WorkSpace\notes-gd\notes\中间件实战.assets\image-20200725124203774.png)

**红包分配方案**

一个简单的实现方法：二倍均值法：根据每次剩余的总金额和剩余个数N，执行M/N*2的操作得到一个边界值E，再随机0-E，得到随机结果R。循环往复，最终得到N个随机的红包。

**Redis的作用**

- 缓存发红包系统中生成的红包个数和每个红包的随机金额，用于提升响应速度
- 利用Redis的单线程特性，保证红包不会出现超抢的情况

**高并发压力测试**

可以使用JMeter进行压力测试，建议在我们自己的系统中进行Jemeter压力测试。

**可能的并发问题**

问题：单个用户并发多次发出抢红包请求，可能出现该用户抢到多个红包的情况。

解决方案：由于有抢到红包的用户记录，因此在抢之前判断该用户是否已经抢到并分配到了红包。注意，判断和抢红包必须是一个原子操作，可以利用Redis的setIfPresent操作。相当于使用了分布式锁。

## 消息中间件 - RabbitMQ

### 应用场景

消息队列的应用场景列举

**异步通信和服务解耦**

将业务流程中的非核心业务剥离出来，异步处理，以加快主业务处理速度。主业务和剥离业务之间采用消息队列解耦。

**接口限流和消息分发**

秒杀或抢购活动中，存在秒级高并发的请求，如果全部由服务器承接下来，服务器可能会被压垮。此时可以在收到请求时将请求入队，同时告知用户正在抢购中，待该请求从队列中拿出来处理完后再异步告知用户处理结果。

这里有两个使用到消息队列的地方

- 接口限流：请求入队，依次取出
- 消息分发：异步通知用户处理结果

**业务延迟处理**

购物时，下单成功后，要求一段时间内支付订单，如到期未支付，则订单会被取消。

传统实现方式：用户下单后，定时检查订单状态，并进行过期判断。这在业务量巨大时几乎不可行。

消息队列方式：用户下单后，将订单加入延迟队列，延迟指定时间，订阅该消息队列，则出现的消息都是到达时间后的，此时再判断用户是否已支付，会节省很多计算资源。

### 消息模型

- FanoutExchange：消息广播
- DirectExchange：直连消息传输
- TopicExchange：发布-主题-订阅

### 消息高可用和确认消费

消息队列会存在如下几个问题

1. 发送出去的消息不知道有没有发送成功
2. RabbitMQ服务挂掉了，没来得及消费掉的消息丢失
3. 消息消费者崩溃，导致消息重复入队，导致被重复消费

RabbitMQ提供的解决方式如下

1. 发送确认机制：可配置发送确认机制，即发送成功后通知发送者
2. 消息持久化：设置消息持久化，即使服务崩溃也不会丢失消息
3. 消息确认机制：即在消费者成功消费消息后，发送ACK给消息服务，消息服务再通知生产者消费成功。确认机制有自动和手动两种：
   - 自动：获取到消息即算成功，发送ACK
   - 手动：需要手动发送ACK，可以在取出消息并完成关键业务后再发送ACK

### 死信队列（延迟队列）

前面所列举的延迟处理的情况，在RabbitMQ中对应的组件叫做死信队列。

RabbitMQ中，一般队列的传输流程如下

![image-20200725175922037](D:\WorkSpace\notes-gd\notes\中间件实战.assets\image-20200725175922037.png)

死信队列则多了一层，用户生产消息后，消息先进入死信队列，在TTL到期时再转入普通队列等待消费者消费。

![image-20200725180053774](D:\WorkSpace\notes-gd\notes\中间件实战.assets\image-20200725180053774.png)

## 分布式锁

### 分布式锁的要求

分布式锁的几点要求

- 排他性

  基本要求

- 避免死锁

  锁被获取后，经过一段时间，必须被释放

- 高可用

  获取和释放锁的机制必须高可用，且性能极佳

- 可重入

  当前机器第一次没有获取到，那么再等待一定时间后一定要保证可以再次被获取到。ZK天然支持

- 公平锁

  每个节点获取到锁的概率最好是一样的。

### 常见的几种分布式锁

- 基于数据库的锁

  - 乐观锁

    不显式加锁，仅在要更新数据时判断目标数据是否已经被其他进程修改过，修改过则不再进行更新（一般是retry），否则直接更新。

    这通常是通过版本号的方式实现，如线程1查询时候获取到version为1，线程2获取到version也为1，在线程1执行更新后，将其version置为2，线程2再去更新时，发现目标数据版本号和自己的版本号不一致，则知道它已经被其他线程修改过了。

    它适用于数据冲突发生较少的场景，比如大量读，少量写，如果数据冲突发生过多，会造成多次retry，造成性能损失。

    ```sql
    update locktable set value = newValue, version = version + 1 where key = 1
    ```

    乐观锁的问题在于重试机制会比较麻烦。

  - 悲观锁

    ```sql
    SELECT ... FOR UPDATE
    ```

    读取时即将相关记录锁定，会对性能造成较大影响。

    它适用于数据冲突发生多的场景，如大量写，少量读。

- 基于Redis原子操作的锁：SETNX EXPIRE

  利用了Redis单线程的特性，每个命令都是原子的，结合EXPIRE防止了死锁。

  但是利用Redis实现的锁，还是有它自己的问题，具体可以看这篇博客文章：http://zhangtielei.com/posts/blog-redlock-reasoning.html

- 基于Zookeeper的互斥排他锁

  通过创建临时的有序节点+Watcher机制

  **ZK分布式锁实现原理**

  节点：在谈及分布式的时候，通常所说的“节点”指的是组成集群的每一台机器。然而在ZooKeeper中，“节点”分为两种类型，第一种是指构成集群的机器，我们称之为机器节点；第二种则是指数据模型中的数据单元，我们称之为数据节点，即前文介绍的ZNode，而在图7.54中组成ZooKeeper底层基础架构的节点指的正是ZNode。

  ![image-20200725190512961](D:\WorkSpace\notes-gd\notes\中间件实战.assets\image-20200725190512961.png)ZooKeeper将所有数据存储在内存中，最终构成的数据模型可以看作是一棵树（ZNode Tree），由斜杠“/”进行分割，分割之后的每个分支即为路径，每个路径对应的即为一个ZNode，例如/ZNode1/Node1，每个节点都会保存自己的数据内容及一系列的属性信息。在ZooKeeper中，ZNode可以分为“持久节点”和“临时节点”两种类型。
  持久节点，顾名思义，指的是一旦这个ZNode被创建了，除非主动移除这个ZNode，否则它将一直保存在ZooKeeper上。而临时节点则不一样，它的生命周期是和客户端的会话绑定在一起的，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除。除此之外，ZooKeeper创建的临时节点ZNode可以带上一个整型的数字，这个特性可以用来创建一系列带有顺序序号标识的临时ZNode。
  Watcher监听器：指的是“事件监听器”，由于ZooKeeper允许用户在指定的节点ZNode上注册“监听”事件，因而当该节点触发一些特定的事件时，ZooKeeper服务端即Server会将事件通知到感兴趣的客户端Client上，从而让客户端做出相对应的措施。值得一提的是，这种机制是ZooKeeper实现分布式协调服务的重要特性。

  **ZK实现分布式的原理就是创建临时节点，如果一个客户端创建临时节点成功，则获取锁成功，否则获取失败。获取成功后，服务端会监听来自客户端的心跳，当客户端无心跳时，服务端将该临时节点删除，锁释放。**

  而关于如何实现一个标准的ZK分布式锁，可以看这篇文章：https://zookeeper.apache.org/doc/r3.4.9/recipes.html#sc_recipes_Locks

- 基于开源框架Redeisson的分布式锁（基于Redis构建的分布式锁）

### Redis分布式锁和Zookeeper分布式锁对比

ZK实现分布式锁会有如下两个优点

- ZK客户端可以锁任意长时间，而Redis必须在超时前完成，除非手动续期（实现类型ZK的心跳机制）
- ZK利用watcher监听机制，支持获取锁失败后等待直到锁获取成功，Redis是不支持的

### 分布式锁的应用场景

凡是需要保证GET-COMPARE-UPDATE操作的原子性的场景，都可以使用分布式锁，举两个例子

- 为了防止订单超卖，“查询商品->判断商品是否还有库存->商品减库存”需保证原子性，于是在查询之前枷锁，商品减库存之后释放锁
- 为防止用户重复提交注册信息，“查询用户是否已存在->插入新用户”需保证原子性，于是在查询之前枷锁，插入新用户之后释放锁

## Redisson

Redis son，Redisson是基于Redis而实现的一系列分布式工具的集合，底层基于Netty。实现了远超Redis原生的功能。

- 数据序列化：帮忙做了Java到Redis数据类型的序列化
- 集合分片：将一个大集合次啊分为若干个片段，分布到集群的各个节点中
- 分布式对象：如布隆过滤器、BitSet等
- 分布式集合：List、Set、Map，这个和原生的Redis提供的一致
- 分布式锁：核心组件，针对不同的场景基于Redis实现了不同的分布式锁
- 分布式服务：可实现服务的远程调用

Redisson的目标是，将Redis和各种场景封装成现成的API，使得使用者可以专心于业务逻辑。

### Redisson分布式锁

Redis锁的常规实现存在过期时间不好控制、不可重入等问题，Redisson针对不同的情况实现了多种锁。

- 可重入锁 - Reentrant Lock
- 公平锁 - Fair Lock
- 联锁 - MultiLock
- 红锁 - RedLock
- 读写锁 - ReadWriteLock
- 信号量 - Semaphore
- 闭锁 - CountDownLatch

**Redisson解决过期时间的方案**

设立一个看门狗，未显式释放锁之前，每30秒为key续期一次。

**Redisson解决锁不可重入的问题**

获取锁失败之，每隔一段时间，尝试重新获取锁。

## 想法

### 乐观锁和悲观锁

乐观锁和悲观锁只是一种思想，实际中的锁只是这些思想的实现。比如数据库的SELECT FOR UPDATE、Java的synchronized、Lock等，都是悲观锁的实现。而java的atomic中的原子变量类的CAS机制就是使用了乐观锁。