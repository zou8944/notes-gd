# Redis开发与运维 读书笔记

# 目录

这是一本偏运维的书籍，没必要从头到尾完全看，我本次观看的目的在于搞清楚Redis到底是什么东西，以及Redis实现缓存、分布式队列的原理。为此，需要学习的章节如下

- 第1章：初识Redis——详细看
- 第2章：API的理解和使用——简单看
- 第3章：小功能大用处——简单看
- 第4章：客户端——跳过
- 第5章：持久化——简单看
- 第6章：复制——简单看
- 第7章：Redis的噩梦:阻塞——**详细看**
- 第8章：理解内存——**详细看**
- 第9章：哨兵(高可用)——简单看
- 第10章：集群——简单看
- 第11章：缓存设计——**详细看**
- 最后三章：简单看

# 第1章：初始Redis

## 特点

- 能够存储各种各样的值，因此能够满足多种应用场景
- 所有数据放在内存中，因此读写性能惊人
- 数据能够持久化，不会出现一般内存数据库丢失数据的情况
- 功能强大
  - key过期
  - 发布订阅
  - 事务
  - 流水线
  - Lua脚本

### 优点

- 速度快，官方宣称QPS为10万/秒
  - 所有数据放内存
  - C语言实现
  - 单线程架构，预防了多线程竞争
  - 源代码精细打磨，Redis是少有的集性能和优雅于一身的开源代码

- 存储值不仅是字符串，还可以是具体的数据结构，主要提供5中数据结构

  - 字符串
  - 哈希
  - 列表
  - 集合
  - 有序集合

  额外提供三种数据结构

  - 位图
  - HyperLogLog
  - GEO(地理位置定位，Redis3.2开始)

- 丰富的功能
  - key过期功能 —— 可做缓存用
  - 发布-订阅功能 —— 可做消息系统
  - 支持Lua脚本 —— 可自定义Redis命令
  - 简单的事务功能 —— 一定程度上保证事务特性
  - 提供流水线功能 —— 客户端能将一批命令传到Redis，减少网络开箱

- 简单稳定
  
- 加上集群版的源代码也只有5万行左右，开发人员可以吃透它
  
- 持久化
  
  - 提供RDB和AOF两种策略进行数据持久化
- 主从复制
  
- 提供复制功能，是分布式Redis的基础
  
- 高可用和分布式
  - 从2.8开始提供高可用实现 Redis Sentinel，确保节点故障发现和故障自动转移
  - 从3.0开始提供分布式实现 Redis Cluster

### Redis不适合做

- 数据量非常大时，由于Redis存放在内存中，经济成本会非常高
- 冷数据不适合(即不需要经常操作的数据)，将冷数据存储在Redis中是对内存的浪费

### 总结

Redis是一个数据库，其原始作者开发它的目的也是构建一个属于自己的数据库，缓存只是它的一部分比较小的功能，这点千万要记住，不要像是理解Memcached那样去理解它。

## Redis启动

- 启动服务端

  ```bash
  redis-server //直接启动，默认配置
  redis-server --port 3304 启动时指定启动参数
  redis-server /configfile 启动时指定启动配置文件
  ```

  redis目录下有一个redis.conf配置文件，这是它的默认配置文件。

- 启动客户端

  - 交互式

    ```bash
    redis-cli -h 127.0.0.1 -p 6639
    ```

  - 命令式

    命令式能够直接得到要执行的命令的值

    ```bash
    redis-cli -h 127.0.0.1 -p 6639 get key
    ```

- 停止Redis服务

  ```bash
  redis-cli shutdown
  ```

### 注意事项

- redis shutdown是一个过程：断开与客户端的连接 -> 生成持久化文件
- 直接kill进程号会造成持久化失败，缓冲区资源不能及时回收等后果
- shutdown有 save | nosave 参数，用于指定关闭前是否需要生成持久化文件

## Redis的版本

- 奇数版本为开发版
- 偶数版本为正式版
- 这种命名规则参考Linux

- 写这篇笔记时，已经是Redis 6.0版本，而写该书的时间点还是4.0版本，书则是以3.0版本进行介绍。

### 在本书到当前这段时间，Redis主要升级了什么



# 第2章 API的理解和使用

命令介绍不记笔记，需要时自己看书去

## 预备

### 数据结构

Redis的五种数据结构如下

![image-20200607213518735](/home/floyd/PersonalCode/notes-gd/notes/Redis开发与运维学习笔记/image-20200607213518735.png)

每种数据结构有多种编码

![image-20200607213622868](/home/floyd/PersonalCode/notes-gd/notes/Redis开发与运维学习笔记/image-20200607213622868.png)

### 单线程模型

所有客户端想Redis服务端发送的命令都会进入队列，服务端在单线程上依次执行。

### Redis快的原因

- 纯内存访问，保证了Redis在服务端本地是快的
- 非阻塞IO，使用epoll作为IO多路复用的技术实现
- 单线程避免了线程切换和竞争产生的消耗

可以看到，后面两个点，是目前主流响应式框架的主流方式。

## 字符串

字符串类型可以存任意类型的字符串(包括JSON，XML等)、数字、二进制。上限为512MB。从上面的string内部编码上也可以看出

### 常用命令

- set
- get
- mset
- mget 节省的网络时间，在服务端命令还是一条一条地执行的
- incr 因为单线程模型，Redis的自增不会使用CAS，因此没有多余的CPU消耗
- decr
- incrby
- decrby
- incrbyfloat
- append 向字符串尾部追加
- strlen 计算字符串字节数
- 。。。。。。

![image-20200609213405519](/home/floyd/PersonalCode/notes-gd/notes/Redis开发与运维学习笔记/image-20200609213405519.png)

### 内部编码

- int 8字节的长整型
- embstr 小于等于39字节的字符串
- raw 大于39字节的字符串

Redis根据当前值的类型和长度决定使用哪种内部编码

### 查看一个值的内部编码

```bash
object encoding key
```

## 哈希

hash就是一般说的字典、关联数组等

### 命令

- hset
- hget
- hdel
- hlen
- hmget
- hmset
- hexists
- hkeys 获取所有field
- hvals 获取所有value
- hgetall 获取所有field-value
- hincrby 对field中的值自增
- hincbyfloat
- hstrlen 对field的值计算字符串长度

![image-20200609214530886](/home/floyd/PersonalCode/notes-gd/notes/Redis开发与运维学习笔记/image-20200609214530886.png)

![image-20200609214546157](/home/floyd/PersonalCode/notes-gd/notes/Redis开发与运维学习笔记/image-20200609214546157.png)

### 内部编码

- ziplist 压缩列表，当哈希类型元素个数小于hash-max-ziplist-entries(默认512)，且所有值都小于hash-max-ziplist-value(默认64字节)时，使用压缩列表，它以更加紧凑的结构实现多个元素连续存储，节省内存
- hashtable 无法满足ziplist条件时，使用hash表，寻址时间复杂度为O(1)

### 应用场景

- 将关系型数据库的一条记录以hash的形式存储到redis中，比直接序列化成字符串存要直观。

## 列表

一个列表最多存放 2^32 - 1 个元素

### 命令

![image-20200609215524477](/home/floyd/PersonalCode/notes-gd/notes/Redis开发与运维学习笔记/image-20200609215524477.png)

![image-20200609215818831](/home/floyd/PersonalCode/notes-gd/notes/Redis开发与运维学习笔记/image-20200609215818831.png)

### 内部编码

- ziplist 压缩列表，当列表元素个数小于list-max-ziplist-entries、列表中每个元素小于list-ziplist-value时，redis采用它作为list的内部编码
- linkedlist 链表

### 使用场景

- 消息队列 lpush + brpop 实现消息队列

## 集合

一个集合最多存放 2^32 - 1 个元素

### 命令

![image-20200609221731326](/home/floyd/PersonalCode/notes-gd/notes/Redis开发与运维学习笔记/image-20200609221731326.png)

### 内部编码

- intset 整数集合，集合中元素都是整数且个数小于set-max-intset-entries时，使用它，减少内存使用
- hashtable 哈希表

## 有序集合

给每个元素一个score作为排序的依据，有序集合的元素不能重复，但score可以重复

### 命令

![image-20200609222800597](/home/floyd/PersonalCode/notes-gd/notes/Redis开发与运维学习笔记/image-20200609222800597.png)

### 内部编码

- ziplist 当元素个数小于zset-max-ziplist-entries配置(默认128个)，每个元素的值小于zset-max-ziplist-value(默认64字节)时，使用ziplist
- skiplist 跳跃表

### 应用场景

- 排行榜，score作为排行依据

## 键管理

可以对键做的事情包括

- 重命名键(重命名键会删除原键，如果值很大，可能会阻塞)

- 随机返回一个键

- 键过期(可设置毫秒级别)

- 迁移键(从一个库迁移到另一个库)

- 遍历键 不建议使用，键过多时很容易阻塞

  ```bash
  keys pattern // pattern有自己的规则
  ```

- 渐进式遍历键

  ```bash
  scan cursor [match pattern] [count number]
  ```

  - cursor 游标
  - match pattern 匹配的规则
  - count number 每次返回的键数量

  scan能够解决keys存在的问题，其时间复杂度为O(1)，redis采用hashtable的结构存储键值对，scan每次只获取一部分键，并返回游标位置，下次传入上次返回的位置，继续获取，直到返回的游标为0表示完成为止。

  scan的缺点：遍历中如有新增键，则可能出现重复遍历或遍历缺失的情况。

## 数据库管理

- 切换数据库

  Redis使用数字标示多个数据库，默认配置一个Redis有16个数据库。数据库之间没有任何关联，甚至可以存储相同的键。

  ```bash
  select 0 // 切换到0号数据库
  ```

  默认使用0号数据库。从3.0开始，已经淡化了多数据库的功能。因为对于单线程的工作模型，多数据库意义不大。完全可以部署多个Redis实例。

- 清除数据库

  ```bash
  flushdb	# 清除当前数据库，类似truncate的操作，要谨慎
  flushall # 清除所有数据库
  ```

## setnx、setxx(分布式锁)

setnx等效set -nx，key必须不存在，用于插入

setxx等效set -xx，key必须存在，用于更新

由于Redis是单线程的，结合setnx和setxx，可以用来做分布式锁。https://redis.io/topics/distlock，看本文档最后的记录。

# 第3章 小功能 大用处

## 慢查询分析

慢查询日志的原理就是卡命令执行前后的时间差，当超过一定阈值时，就将相关信息记录下来。

如下是一个命令的执行生命周期

![image-20200609230405101](/home/floyd/PersonalCode/notes-gd/notes/Redis开发与运维学习笔记/image-20200609230405101.png)

### 配置

- showlog-log-slower-than 指定蛮查询阈值
- showlog-max-len 最多存储多少条慢查询日志。日志存在一个列表中，该参数设置列表长度

### 获取慢查询

- showlog get

## Redis Shell

介绍了Redis命令行工具的一些巧妙用法

## Pipline

问题：上面说过，Redis执行一条命令周期为 客户端发送命令 -> 命令排队 -> 命令执行 -> 服务端返回结果，其中第一步和第四步共同叫做往返时间(RTT)。部分操作如mget提供了一次操作多个key的功能，节省了RTT，但并非所有命令都支持批量操作，对于没有批量操作的命令，还是存在浪费RTT的情况

解决：Pipline，能够将任意命令打包执行，再打包返回，从而节省RTT

### 对比原生批量命令

- 原生批量命令是原子的，而Pipline不是
- 原生批量命令只支持多个key，而Pipline支持多个命令
- 原生批量命令是服务端支持实现的，而Pipline是客户端与服务端共同实现的

## 事务和Lua

支持简单的事务，简单是因为不支持回滚。

## Bitmaps

该数据结构可对位进行操作。

- Bitmaps本身并非一种数据结构，他就是字符串，只不过可以对字符串的位进行操作
- Bitmaps提供单独的一套命令，操作起来不像字符串
- Bitmaps的用处主要是节省存储空间，当业务量级达到千万、亿级时，节省空间相当可观，但在十万这种级别时，就不怎么节省了

## HyperLogLog

- 它也不是一种新的数据结构，实际是字符串，是一种基数算法。
- 它只能用来计算独立总数，比如昨天有uuid-1,uuid-2两个用户访问，今天有uuid-2，uuid-3访问，则通过HyperLogLog可计算独立总数为3。由于它不需要记录每条记录，且采用特殊算法，因此占用空间小得惊人。
- 它存在一定误差率，官方说是0.81%

## 发布-订阅

Redis直接支持发布-订阅模式

- 发布消息

  publish channel message

- 订阅消息

  subscribe channel1 channel2 ...

- 取消订阅

  unsubscribe channel1 channel2 ...

- 还可以查看可订阅的channel、查看某channel订阅数、订阅一批channel等

## GEO

从Redis 3.2开始支持地理位置功能，它是借鉴NoSQL数据库Ardb实现的。

- 工作方式

  录入经度、纬度、位置名称

  提供计算两个位置的距离、获取某位置指定距离范围内的其它位置等方便的计算。

# 第7章 Redis的噩梦：阻塞

Redis是单线程架构，一旦阻塞，哪怕时间很短，都将是噩梦

## 内在原因

- API或数据结构使用不合理，如对有上万个元素的hash结构执行hgetall操作

  优化策略

  - 禁用keys、sort等命令
  - hgetall改为hmget等
  - 将大对象拆分为多个小对象，防止一次取过多数据

  **对于慢查询和大对象，redis有专门的命令获取**

- CPU饱和

  指Redis线程将一个CPU核心占满的情况，可以使用redis-cli --stat查看当前吞吐量。如果真的饱和则需要做集群化水平扩展来分摊OPS压力。

- 持久化阻塞

  持久化导致的阻塞，要看请参考书

## 外在原因

- CPU竞争

  Redis是典型的CPU密集型应用，不建议和其它CPU密集型应用部署在一起，以免压缩Redis的CPU资源

- 内存交换

  操作系统有一个内存swap设置，会将一部分内存数据换出到硬盘，如果Redis被交换过去，将会导致卡顿。

  常见优化操作为保证机器有足够的可用内存；确保所有Redis实例设置最大内存占用，以免无止境增长。

- 网络问题

  网络闪段、Redis连接达到最大而拒绝连接等。

# 第11章 缓存设计

## 缓存更新策略

缓存有生命周期，需要在指定时间后被删除或被更新。

- LRU、LFU、FIFO算法剔除

  用于当缓存满时对数据进行剔除

  由于在数据库没满时缓存数据一致不变，因此一致性最差

  维护成本较低

- 超时剔除

  到期自动删除

  超时前一致性不好，维护成本较低

- 主动更新

  开发人员主动更新，一致性好，但维护成本很高。

**建议的方式**

- 低一致性要求的业务配置使用最大内存和算法剔除策略
- 高一致性结合主动更新+超时剔除

## 穿透优化

### 定义

缓存穿透：查询一个根本不存在的数据，会一直向数据库查询，导致缓存没有起到拦截流量保护后端的作用。

### 优化策略

- 缓存空对象

  数据库查询不到时，构建一个空对象，存入缓存，下次直接命中缓存。

  缺点：

  - 会存储更多的键，需要更多内存空间，如果是攻击，可能导致空间很快满。解决办法是对空对象设置较短的超时时间
  - 存在一段时间不一致，如果缓存空对象期间数据库已经插入了数据，则这段时间在缓存中是没有的

- 布隆过滤器拦截

  在访问缓存前先用布隆过滤器拦截，布隆过滤器能够准确判断可能存在和肯定不存在，只有肯定不存在时才访问缓存和数据库。

  可以利用Redis的Bitmaps实现布隆过滤器(github上有实现)

- 二者对比

  缓存空对象代码维护简单，但会导致数据不一致和过多的缓存空间

  布隆过滤器代码相对复杂，但可以解决缓存空间占用高的问题

## 无底洞优化

### 定义

增加缓存服务节点，但性能不但没有好转，反而下降，称为无底洞现象(投入越多产出不一定越多)。

原因：缓存数据库的键值hash与业务无关，可能将同一个业务需要的数据hash到多个水平扩展的节点，造成每次读取时都会有多次网络IO操作(最优情况只需要一次网络IO)，造成性能的下降。

### 优化策略

- 串行命令

  常规显示，这种方式谈不上优化，即一次获取一个key，复杂度为n次网络+n次命令执行时间。

  该方法唯一好处是实现简单

- 串行IO

  对key计算slot值，根据slot值和节点的对象关系，将key分为多个组，每个组采用pipline或mget，复杂度为node次网络+n次命令执行时间。

- 并行IO

  将串行IO方案的每个组采用多线程的方式请求，使得网络时间并行

- hash_tag

  Redis集群功能有hash_tag功能，可以将多个key强制分配到一个节点上，这样其时间复杂度为1次网络命令+n次命令时间

## 雪崩优化

### 定义

如果由于某些原因缓存层不能提供服务，导致所有请求都会到达存储层，造成存储层跟随宕机，这叫做雪崩

### 优化策略

- 保证缓存层服务高可用

  使用Redis Sentinel和Redis Cluster功能，即使节点挂掉了整个服务也不会挂

- 组件隔离+后端降级

  这是方案级别的优化了

  将每个资源隔离，使用不同的线程池。对于挂掉的服务，将数据降级，比如如果推荐数据缓存挂掉了，可以降级为一般数据。

  资源隔离，可以使用依赖隔离工具Hystrix

## 热点key重建优化

### 定义

使用缓存+过期时间的策略时，当缓存过期且缓存重建需要大量时间时，如果该key是热点key，则该窗口期大量请求会直接打到数据库，可能造成数据库崩溃。

### 优化策略

- 互斥锁

  只允许一个线程重建缓存，其它线程等待缓存重建完成后再重新从缓存中获取数据即可

  使用redis的mutex key

  该方法的风险是如果重建时间过长可能导致思索

- 永不过期

  设置缓存上永不过期，但在功能代码中定期使用单线程刷新该热点key。

  缺点是重建期间多个请求的数据可能不一致

# Redis分布式锁

Redis官方提供了一种基于Redis实现的分布式管理器——Redlock。针对各个语言都有实现，Java对应Redisson

https://redis.io/topics/distlock